<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>The Morph Framework</title><link rel="stylesheet" href="../styles/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.60.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="d0e2"></a>The Morph Framework</h1></div><div><h2 class="subtitle">
          Reference Documentation
        </h2></div><div><div class="authorgroup"><div class="author"><h3 class="author"><span class="firstname">Matthew</span> <span class="surname">Sgarlata</span></h3></div></div></div><div><p class="releaseinfo">Version 1.1.1</p></div><div><div class="legalnotice">Copies of this document may be made for your own use and for distribution to others, provided that you do not charge any fee for such copies and further provided that each copy contains this Copyright Notice, whether distributed in print or electronically.</div></div><div><p class="pubdate">June 13, 2008</p></div></div><div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><a href="#preface">Preface</a></dt><dt>1. <a href="#introduction">Introduction</a></dt><dd><dl><dt>1.1. <a href="#introduction-started">Getting Started</a></dt><dd><dl><dt>1.1.1. <a href="#introduction-convert">Morph.convert</a></dt><dt>1.1.2. <a href="#introduction-copy">Morph.copy</a></dt></dl></dd><dt>1.2. <a href="#introduction-custom">Customizing Morph</a></dt><dt>1.3. <a href="#introduction-concepts">Concepts</a></dt><dd><dl><dt>1.3.1. <a href="#introduction-concepts-transformers">Transformers</a></dt><dt>1.3.2. <a href="#introduction-concepts-reflectors">Reflectors</a></dt><dt>1.3.3. <a href="#introduction-concepts-wrappers">Wrappers</a></dt><dt>1.3.4. <a href="#introduction-concepts-languages">Languages</a></dt><dt>1.3.5. <a href="#introduction-concepts-contexts">Contexts</a></dt></dl></dd></dl></dd><dt>2. <a href="#transformers">Transformers</a></dt><dd><dl><dt>2.1. <a href="#transformers-introduction">Introduction</a></dt><dt>2.2. <a href="#transformers-converters">The Converter Interface</a></dt><dt>2.3. <a href="#transformers-copiers">The Copier Interface</a></dt><dt>2.4. <a href="#transformers-internationalization">Internationalization</a></dt><dt>2.5. <a href="#transformers-transformers">The Transformer Interface</a></dt><dt>2.6. <a href="#transformers-combining">Combining Transformers</a></dt><dt>2.7. <a href="#transformers-implemented">Transformer Implementations</a></dt><dd><dl><dt>2.7.1. <a href="#transformers-implemented-converters">Pre-Built Converters</a></dt><dt>2.7.2. <a href="#transformers-implemented-copiers">Pre-Built Copiers</a></dt><dt>2.7.3. <a href="#transformers-creating">Writing Custom Transformers</a></dt></dl></dd><dt>2.8. <a href="#transformers-graphs">Transforming Arbitrary Object Graphs</a></dt><dd><dl><dt>2.8.1. <a href="#transformers-graph-introduction">Introduction</a></dt><dt>2.8.2. <a href="#transformers-graph-example">Example</a></dt><dd><dl><dt>2.8.2.1. <a href="#d0e436">Transforming VehicleDAO[] to VehicleVO[]</a></dt><dt>2.8.2.2. <a href="#d0e462">Transforming PersonDAO[] to String[]</a></dt><dt>2.8.2.3. <a href="#d0e509">Transforming AddressDAO[] to String</a></dt><dt>2.8.2.4. <a href="#d0e519">Transforming PersonDAO[] to PersonVO[]</a></dt></dl></dd></dl></dd></dl></dd><dt>3. <a href="#wrappers">Wrappers</a></dt><dd><dl><dt>3.1. <a href="#wrappers-introduction">Introduction</a></dt></dl></dd><dt>4. <a href="#contexts">Contexts</a></dt><dd><dl><dt>4.1. <a href="#contexts-introduction">Introduction</a></dt></dl></dd></dl></div><div class="preface" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="preface"></a>Preface</h2></div></div><div></div></div><p>Morph is a Java framework that eases the internal interoperability of an application.  As information flows through an application, it undergoes multiple transformations.  Morph provides a standard way to implement these transformations.  For example, when a user submits data using an HTML form in a J2EE application, the data typically goes through three transformations.  First, HTTP request parameters are converted to presentation-tier command objects.  Second, the command objects are converted into business objects.  Finally, the business objects are persisted to a database.</p><p>In addition to providing a framework for performing transformations like those described above, Morph provides implementations of many common transformations, including all three of the transformations in the example above (1 is partly done now, 2 and 3 are done).  As you can see, Morph is surprisingly powerful out-of-the-box, but it can't solve every problem.  Instead, it provides a simple API you can use to harness its power for your particular situation.  It has been built from the ground up for flexibility and extensibility, and integrates seamlessly with dependency injection frameworks such as <a href="http://www.springframework.org" target="_top">Spring</a>, <a href="http://www.picocontainer.org/" target="_top">PicoContainer</a> and <a href="http://jakarta.apache.org/hivemind/" target="_top">Hivemind</a>.</p><p>Many of the ideas in Morph were inspired by the Apache Jakarta Commons <a href="http://jakarta.apache.org/commons/beanutils/" target="_top">BeanUtils</a> project, the Apache Jakarta Commons sandbox component called <a href="http://jakarta.apache.org/commons/sandbox/convert/" target="_top">Convert</a> and the <a href="http://jakarta.apache.org/commons/chain/apidocs/org/apache/commons/chain/Context.html" target="_top">Context</a> notion of the Apache Jakarta Commons <a href="http://jakarta.apache.org/commons/chain/" target="_top">Chain</a> project.  Morph synthesizes ideas from these various areas into one consistent API.  Implementations are be provided that solve many common problems such as mapping HTTP request parameters to POJOs and converting a SQL statement into Java objects.</p><p>
		Special thanks to the developers of Hibernate and the Spring framework.
		This methods for generating this documentation were taken from Spring,
		which was in turn adapted from Hibernate.
	</p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="introduction"></a>Chapter&nbsp;1.&nbsp;Introduction</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="introduction-started"></a>1.1.&nbsp;Getting Started</h2></div></div><div></div></div><p>The easiest way to use Morph is to use the <tt class="literal">Morph</tt> static class.  The main operations it supports are <tt class="literal"><a href="#transformers-converters" title="2.2.&nbsp;The Converter Interface">convert</a></tt>, <tt class="literal"><a href="#transformers-copiers" title="2.3.&nbsp;The Copier Interface">copy</a></tt>, <tt class="literal"><a href="#">get</a></tt> and <tt class="literal"><a href="#">set</a></tt>.  These methods allow you to: <tt class="literal">convert</tt> an object from one type to another, <tt class="literal">copy</tt> information from one object to another (already existing) object, retrieve (<tt class="literal">get</tt>) information from anywhere in an object graph and <tt class="literal">set</tt> information anywhere in an object graph, respectively.</p><p>The benefit of using the <tt class="literal">Morph</tt> static class directly is that it's simple, and you don't have to do any special setup.  No matter what project you're working on, all you have to do is drop the morph JAR into your project's library directory and reference the Morph class.  In addition, you are assured that no matter how the application you are working on is configured, Morph will work the way you're used to.</p><p>The drawback of using Morph in this way is that you cannot do any customization.  The <tt class="literal">Morph</tt> class is a static facade that makes it easy to get started using Morph.  To accomplish this goal, it hides all of the powerful customizations Morph provides.  Fortunately, once you outgrow the capabilities that come with Morph out of the box, your own custom Morph configuration will live peacefully side by side with the Morph static class.  Your existing code that utilizes the Morph static class will continue to work as it did before, and the parts of your application that require special configuration can have that special configuration limited to only those parts of the system that need the added complexity.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="introduction-convert"></a>1.1.1.&nbsp;Morph.convert</h3></div></div><div></div></div><p>Morph.convert allows you to convert an object from one type to another. Here are some examples:</p><pre class="programlisting">
Integer three = new Integer(3);
// code without Morph
String string = new Integer(three);
// or (without using Morph)
string = "" + three;
// code using Morph
String string = Morph.convertToString(three);

String three = "3";
// code without Morph
Integer integer = new Integer(three);
// code using Morph
Integer integer = Morph.convertToIntegerObject(three);

String three = "3";
// code without Morph
int i= new Integer(three).intValue();
// or (without using Morph)
int i = Integer.parseInt(3);
// code using Morph
int i = Morph.convertToInt(three);
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="introduction-copy"></a>1.1.2.&nbsp;Morph.copy</h3></div></div><div></div></div><p>Morph.copy allows information from one object to be copied to another object. The object to which information is copied may even be of a different type than the source object. A great example of when you need to do this type of thing is when you need the data in an HttpServletRequest to be available to lower tiers in your application but you don't want to tie your entire application to the servlet API. For example, let's say you are trying to get your data prepared for a method with a signature <tt class="literal">IServiceInterface.service(Map data):</tt></p><pre class="programlisting">
// without Morph
Map data = new HashMap();
for (Enumeration e=request.getParameterNames(); e.hasNext(); ) {
	String param = (String) e.next();
	data.put(param, request.getParameter(param));
}
// with Morph
Map data = new HashMap();
Morph.copy(data, request);
// actually with this particular example could also do
Map data = (Map) Morph.convert(Map.class, request);
</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="introduction-custom"></a>1.2.&nbsp;Customizing Morph</h2></div></div><div></div></div><p>A common convention in Java programming is to write objects as JavaBeans and expose their configuration parameters as JavaBean properties.  The Morph framework exposes all configuration options in this way.  This allows Morph to be configured programmatically using simple syntax.  An even more powerful way to configure Morph is to use a dependency injection framework such as Spring.  (Dependency injection frameworks are also sometimes called Inversion of Control containers, or IoC containers).  This will allow you to configure Morph using the same format you use to configure the rest of your application.</p><p>If you're completely lost at this point and wondering what the heck a dependency injection framework is, take a look <a href="http://www.picocontainer.org/Dependency+Injection" target="_top">here</a>.  Note that Morph uses Setter Injection rather than Constructor Injection.  I (Matt Sgarlata) personally think dependency injection containers are the most significant innovation in computer programming since object orientation.  If you don't know what dependency injection is, stop now and take a look at Spring, PicoContainer, or Hivemind!  My favorite is Spring.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="introduction-concepts"></a>1.3.&nbsp;Concepts</h2></div></div><div></div></div><p>There is a whole lot of code in the Morph framework, but it all boils down to a few basic types of things: Transformers, Reflectors, Wrappers, Languages and Contexts.  Each of these types of things is given its own package.  We'll use the remainder of this section to briefly cover these types.  For more information on a type, see the reference guide chapter about the type if one has been written.  If you need more information or there is no reference chapter, see the <a href="http://morph.sourceforge.net/apidocs/index.html" target="_top">JavaDoc</a> documentation.  Documentation can always be improved, but the documentation for each of the main interfaces is fairly complete.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="introduction-concepts-transformers"></a>1.3.1.&nbsp;Transformers</h3></div></div><div></div></div><p>Transformers transform data from one type to another.  Transformers were essentially the inspiration for the entire framework, and they are targeted pretty squarely at the original goal for the framework, which was "to be able to convert anything to anything".</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="introduction-concepts-reflectors"></a>1.3.2.&nbsp;Reflectors</h3></div></div><div></div></div><p>Reflectors were originally created to help implement Copiers, which are a type of Transformers.  They provide a stateless model for accessing data from two main types of data structures: bean-like structures and container-like structures.  It turns out reflectors are so useful, they can implement all sorts of neat functionality.  If you have some type of special data type that you need Morph to understand, you probably want to write a Reflector.  A good example of this is the <tt class="literal">DynaBeanReflector</tt></p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="introduction-concepts-wrappers"></a>1.3.3.&nbsp;Wrappers</h3></div></div><div></div></div><p>Wrappers are very similar to reflectors, and in fact their APIs are nearly identical.  The difference is that reflectors are stateless so that transformers can be implemented efficiently.  Wrappers are more useful when you want to allow a method to take any type of bean-like or container-like data, but you don't want to have to overload the method for every conceivable bean (e.g. Object, Map) or container (e.g. Array, List)</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="introduction-concepts-languages"></a>1.3.4.&nbsp;Languages</h3></div></div><div></div></div><p>Languages define a way to retrieve and modify arbitrary information in an object graph.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="introduction-concepts-contexts"></a>1.3.5.&nbsp;Contexts</h3></div></div><div></div></div><p>Contexts are similar to bean wrappers in that they provide stateful access to information stored in a bean-like object.  Unlike beans, contexts are backed by the full power of a language, so they can be used to modify and change any information in an object graph.  Also, the default context implementations provided with Morph implement the Map interface.  This allows you to easily pass Contexts between tiers of an application, even if different tiers of the application are dependent on different APIs (e.g. the Servlet API in the presentation tier and the JDBC API in the resource tier).</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="transformers"></a>Chapter&nbsp;2.&nbsp;Transformers</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transformers-introduction"></a>2.1.&nbsp;Introduction</h2></div></div><div></div></div><p>A transformer transforms information taken from a source and makes it available at a destination.  There are two main types of Transformers: Converters and Copiers.  Converters convert an object of one type to a new object of a different type.  Copiers copy information from an existing object to an existing object of a different type.  Before we get into the reason for having two types of Transformers, let's take a closer look at Converters.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transformers-converters"></a>2.2.&nbsp;The Converter Interface</h2></div></div><div></div></div><p>As previously mentioned, Converters allow an object of one type to be converted to an object of a different type.  Here is the Converter interface:</p><pre class="programlisting">
public interface Converter extends Transformer {

	public Object convert(Class destinationClass, Object source, Locale locale)
		throws TransformationException;

}
		</pre><p>As you can see, the Converter interface is very simple.  By calling the convert method you are saying, "convert <tt class="literal">source</tt> into a new instance of <tt class="literal">destinationClass</tt>".  This is the interface to use when you're doing a simple conversion from one basic type to another.  For example, Morph includes converters that will convert a String to an int (<tt class="literal">TextToNumberConverter</tt>), a String to a StringBuffer (<tt class="literal">TextConverter</tt>) and many other converters.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transformers-copiers"></a>2.3.&nbsp;The Copier Interface</h2></div></div><div></div></div><p>Now let's take a look at the Copier interface:</p><pre class="programlisting">
public interface Copier extends Transformer {

	public void copy(Object destination, Object source, Locale locale)
		throws TransformationException;

}
		</pre><p>The Copier interface is just as simple as the Converter interface.  A call to the copy method basically means, "copy the information from the <tt class="literal">source</tt> to the existing <tt class="literal">destination</tt>.  Copiers are used when you want to avoid or cannot create a new instance of the destination object.  For example, if you want to copy the information in a <tt class="literal">Map</tt> to a <tt class="literal">HttpServletRequest</tt>'s attributes, you can't create a new <tt class="literal">HttpServletRequest</tt> request object, because the servlet container already creates the request object, and you can't create your own.  An example of when you could but wouldn't want to create a new instance of the destination object is if you have multiple source objects that you want to be combined into one destination object.  For example, if you had information in three different <tt class="literal">Map</tt>s that you would like copied to a single destination business object, you could call the copy operation multiple times with your existing business object as the destination object for all three copy operations.</p><p>Now that we've gone over why there are two different types of Transformers, let's make a simple rule of thumb you can use to determine if you should implement a Copier or a Converter: <span class="emphasis"><em>always prefer the Copier interface</em></span>.  In other words, if the transformation you're writing can be expressed as a Copier, you should implement the Copier interface.  This is because any copier can easily implement the convert operation: just create a new instance of the destination class, and then call the copy operation.  In fact, if you subclass the <tt class="literal">BaseCopier</tt>, you will just have to implement the contract for the copy operation and the <tt class="literal">Converter</tt> interface will be automatically exposed for you.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transformers-internationalization"></a>2.4.&nbsp;Internationalization</h2></div></div><div></div></div><p>You may have noticed that both the convert and copy operations have a <tt class="literal">locale</tt> parameter.  This parameter is useful when you need to internationalize your application.  For example, to convert a Double to a String, you can use the <tt class="literal">Morph.convertToString(Object, Locale)</tt> method which will delegate to the <tt class="literal">NumberToTextConverter</tt>.  Now let's say you want the format of the textual representation of the number to be customized according to the locale of your application's users: English speakers use a period as the decimal separator and Spanish speakers use a comma.  By passing in the correct <tt class="literal">locale</tt>, English users will see the Double 3564.12 as 3564.12 and Spanish users will see that same Double as 3564,12.  You can customize the <tt class="literal">NumberToTextConverter</tt> by subclassing it and overriding its <tt class="literal">getNumberFormat</tt> method.  For example, you could customize the converter to include a thousands separator or round decimals to a certain number of digits.</p><p>If you don't know the locale of your user or the locale isn't important, you can simply pass <tt class="literal">null</tt> in as the Locale.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transformers-transformers"></a>2.5.&nbsp;The Transformer Interface</h2></div></div><div></div></div><p>So far we've skipped over the base interface for Converters and Copiers to highlight the differences between the two interfaces.  Now let's look at the similarities by examining the Transformer interface:</p><pre class="programlisting">
public interface Transformer extends Component {

	public Class[] getSourceClasses();

	public Class[] getDestinationClasses();

}
		</pre><p>These methods allow a transformer to specify the types of transformations it is capable of performing.</p><p>This is a different than the one taken by other frameworks.  In other frameworks, a transformer is responsible for performing a transformation and a separate registry is used to indicate which transformers can do which transformations.  This is like having a restaurant where each person is allowed to eat, but isn't allowed to say what they like to eat.  The restaurant's host examines each person and decides what that person will be served without consulting that person.  As you can imagine, this gets pretty ugly pretty quick.  Logically, each person in the restaurant knows what he or she wants to eat, so why not let them decide?</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transformers-combining"></a>2.6.&nbsp;Combining Transformers</h2></div></div><div></div></div><p>Transformers are easy to use directly with Morph, but we don't always know exactly what we're converting ahead-of-time.  For example, if I have a bunch of objects I want to convert to Strings at once, I don't want to have to write a lengthy if/then statement that picks the right converter.  I'd rather just write <tt class="literal">convert(String.class, source, locale)</tt> and have the correct Converter chosen for me.  To solve this problem, other frameworks introduced a registry where you state which transformers can be used for which transformations.  This solves the problem of choosing how to pick a converter, but as we saw in our restaurant example, it introduces problems of its own.</p><p>Morph's solution to this problem is the <tt class="literal">DelegatingTransformer</tt>.  It's a Transformer just like the other Transformers we've looked at, but instead of doing transformations itself, it delegates to other Transformers.  Continuing with our restaurant example, the DelegatingTransformer is like a buffet.  Each person that enters the restaurant gets in line for the buffet and each person gets to choose what they would like to eat.  Now to really stretch this metaphor: the trick is to arrange the line in such a way that everyone's happy.  Put the picky eaters in the front of the line so they can get what they like to eat, and put your puppy that will eat anything at the back of the line so that everything gets eaten.</p><p>Now let's flee from this crazy restaurant and talk about transformations again.  Morph includes both a <tt class="literal">NumberToTextConverter</tt> and a <tt class="literal">ObjectToTextConverter</tt>.  The <tt class="literal">ObjectToTextConverter</tt> just calls an Object's <tt class="literal">toString</tt> method, whereas the <tt class="literal">NumberToTextConverter</tt> nicely formats a number based on a user's locale.  Clearly, if we're converting a bunch of objects to Strings, we want the <tt class="literal">NumberToTextConverter</tt> to get chosen if the object to be converted is a number.  If the object is not a number, we can fall back to the <tt class="literal">ObjectToTextConverter</tt>.  We specify all this behavior simply by setting the <tt class="literal">delegates</tt> property of the <tt class="literal">DelegatingTransformer</tt>.  The delegates are arranged in order of precedence.  When the <tt class="literal">DelegatingTransformer</tt> does a transformation, it goes to each transformer in turn and asks if it can perform the requested transformation.  If the transformer reaches the end of the list but couldn't find any transformers to do the requested transformation, a <tt class="literal">TransformationException</tt> is thrown.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transformers-implemented"></a>2.7.&nbsp;Transformer Implementations</h2></div></div><div></div></div><p>Morph comes with many Transformers pre-built so that hopefully you won't have to implement any yourself.  In this section we'll briefly examine the transformers that are bundled with Morph, and see how to write our own.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="transformers-implemented-converters"></a>2.7.1.&nbsp;Pre-Built Converters</h3></div></div><div></div></div><p>The Converters included with Morph work with all the basic Java types: primitives, Characters, Strings, StringBuffers, Dates, Calendars, Numbers, Iterators, and Enumerators.  For a complete list, see the JavaDoc of the <tt class="literal">net.sf.morph.transform.converters</tt> package.  To get an idea at a glance of what you can convert to what, see the chart below.  An arrow from one type to another indicates that a conversion in that direction is possible.  For example, Numbers can be converted to Booleans, but not the other way around.</p><p>
				</p><div class="mediaobject" align="center"><img src="images/converters.png" align="middle"><div class="caption"><p>Converters included with Morph</p></div></div><p>
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="transformers-implemented-copiers"></a>2.7.2.&nbsp;Pre-Built Copiers</h3></div></div><div></div></div><p>The Copiers included with Morph are focused on transferring information between <span class="emphasis"><em>bean-like</em></span> objects and <span class="emphasis"><em>container-like</em></span> objects.  Bean-like objects can be copied using the <tt class="literal">PropertyNameMatchingCopier</tt>, which copies information from one object to another based on matching up property names in the source and destination objects.  For example, if you had a PersonDAO data access object and a Person domain object that each had the properties firstName, middleName and lastName, the <tt class="literal">PropertyNameMatchingCopier</tt> would take care of copying the information to and from those two objects automatically.</p><p>If the properties don't match, you can use the <tt class="literal">PropertyNameMappingCopier</tt>.  For example, if PersonDAO used firstName, middleName and lastName as property names and Person used firstName middleName and familyName, the PropertyNameMappingCopier can be customized to do this conversion by setting its <tt class="literal">mapping</tt> property.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="transformers-creating"></a>2.7.3.&nbsp;Writing Custom Transformers</h3></div></div><div></div></div><p>If you need to write a custom transformer, it's easy since Copiers and Converters have such simple interfaces.  We recommend you try to extend an existing, pre-built transformer, but if you can't find one that does what you need you can also directly subclass <tt class="literal">BaseConverter</tt> or <tt class="literal">BaseCopier</tt>.  See the JavaDoc for <tt class="literal">BaseTransformer</tt> for more information.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transformers-graphs"></a>2.8.&nbsp;Transforming Arbitrary Object Graphs</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="transformers-graph-introduction"></a>2.8.1.&nbsp;Introduction</h3></div></div><div></div></div><p>When information is passed between different tiers of an application, it often needs to be transformed into a different format.  Essentially, what you need to do is transform one graph of objects into a different graph of objects with similar information.  Without Morph, this type of code can quickly become a big mess that is difficult to modify when the structure of either object graph is changed.  Morph helps isolate each of the different types of transformations that are happening using a divide-and-conquer approach.  Instead of writing one massive method that does the transformation, you write several Transformer classes, each of which is concerned only with transforming one node in the object graph from one type to another.  You then combine all these Transformers using the <tt class="literal">DelegatingTransformer</tt>.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="transformers-graph-example"></a>2.8.2.&nbsp;Example</h3></div></div><div></div></div><p>In this section we'll look at an example of transforming a data access object that holds information from a database into a value object to be exposed as part of a web service.  Note that this example has been made intentionally as difficult as possible.  Most use cases will require far fewer custom transformers to be written.  You can see this example in action by examining the <tt class="literal">net.sf.morph.examples.person.PersonExampleTestCase</tt>.</p><p>Now let's get started.  Below are our example objects, a PersonDAO (Person data access object) and a PersonVO (Person value object):</p><p>
				</p><div class="mediaobject" align="center"><img src="images/graph-classes.png" align="middle"><div class="caption"><p>The PersonDAO and PersonVO classes</p></div></div><p>
			</p><p>Below is an example PersonDAO object that represents John A. Smith.  As we can see, his firstName is John, his middleName is A. and his lastName is Smith.  His credit card number is 5555 5555 5555 5555.  He has two children, Matthew and Natalie, a home and work address, a Ford Taurus, and a Honda Civic.</p><p>
				</p><div class="mediaobject" align="center"><img src="images/graph-persondao.png" align="middle"><div class="caption"><p>John A. Smith represented as a PersonDAO</p></div></div><p>
			</p><p>We would like to convert John's PersonDAO into a PersonVO, like the one shown below.  Notice the creditCardNumber information is removed and his firstName, middleName and lastName have been combined to provide a single name.  Similarly, all his address information was squished into a single String by listing only his primaryAddress, and converting it to a String representation.  Finally, his Ford Taurus and Honda Civic are now just a Taurus and a Civic, because in our VehicleVO we decided we didn't need to include information about the vehicle's manufacturer.</p><p>
				</p><div class="mediaobject" align="center"><img src="images/graph-personvo.png" align="middle"><div class="caption"><p>John A. Smith represented as a PersonVO</p></div></div><p>
			</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e436"></a>2.8.2.1.&nbsp;Transforming VehicleDAO[] to VehicleVO[]</h4></div></div><div></div></div><p>First we'll focus on converting the vehicles property of the PersonDAO to the vehicles property of the PersonVO.  We'll assume for this example that the <tt class="literal">VehicleDAO</tt> can be converted to a <tt class="literal">VehicleVO</tt> by simply using the <tt class="literal">PropertyNameMatchingCopier</tt>.  If this is the case, the <tt class="literal">ContainerCopier</tt> will be able to use the <tt class="literal">PropertyNameMatchingCopier</tt> to convert the <tt class="literal">VehicleDAO[]</tt> to a <tt class="literal">VehicleVO[]</tt> without any further effort on our part.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e462"></a>2.8.2.2.&nbsp;Transforming PersonDAO[] to String[]</h4></div></div><div></div></div><p>For the children property of the <tt class="literal">PersonDAO</tt>, we will need to convert a <tt class="literal">PersonDAO[]</tt> array to <tt class="literal">String[]</tt>.  If we assume that a <tt class="literal">PersonDAO</tt> can be converted to a <tt class="literal">String</tt> by simply calling the object's <tt class="literal">toString</tt> method, the <tt class="literal">ContainerCopier</tt> can do this conversion.  It will automatically delegate to the <tt class="literal">ObjectToTextConverter</tt> to handle the <tt class="literal">PersonDAO</tt> to String conversion.  If we want to write a different converter to handle the <tt class="literal">PersonDAO</tt> to <tt class="literal">String</tt> conversion, we can configure a <tt class="literal">ContainerCopier</tt> to use it by setting the <tt class="literal">ContainerCopier</tt>'s <tt class="literal">graphTransformer</tt> property.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e509"></a>2.8.2.3.&nbsp;Transforming AddressDAO[] to String</h4></div></div><div></div></div><p>Now we'll focus on copying the PersonDAO.addresses property to the VehicleVO.primaryAddress property.  We will also assume that a PersonDAO can be converted to a String by calling the object's toString method.  We will have to write our own converter that takes a <tt class="literal">PersonDAO[]</tt> and transforms it to a String:</p><pre class="programlisting">
public class AddressDAOArrayToStringConverter extends BaseConverter {

	protected Object convertImpl(Class destinationClass, Object source,
		Locale locale) throws Exception {
		
		// the BaseConverter will make sure the source is of the correct type
		// for us, so we can just do a cast here with no error checking
		AddressDAO[] addresses = (AddressDAO[]) source;
		// we can also assume the source is not null, because we didn't
		// explicitly state that null was a valid source class
		AddressDAO address = addresses[0];
		// now we convert the first address to a String
		return address.toString();
		
	}

	protected Class[] getSourceClassesImpl() throws Exception {
		// if we wanted this converter to also handle converting null values
		// to Strings, we could write this line as:
		//
		//      return new Class[] { AddressDAO[].class, null };
		return new Class[] { AddressDAO[].class };
	}

	protected Class[] getDestinationClassesImpl() throws Exception {
		return new Class[] { String.class };
	}

}
				</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e519"></a>2.8.2.4.&nbsp;Transforming PersonDAO[] to PersonVO[]</h4></div></div><div></div></div><p>Now that we know which converters we need to transform the properties of a <tt class="literal">PersonDAO</tt> to the properties of a <tt class="literal">PersonVO</tt>, we are ready to transform our top-level <tt class="literal">PersonDAO</tt> object into a top-level <tt class="literal">PersonVO</tt> object.  We will be able to use the <tt class="literal">PropertyNameMappingCopier</tt> to do most of the work, but we will need to subclass it to handle the conversion of the PersonDAO.firstName, personDAO.middleName and personDAO.lastName properties into a single PersonVO.name property.  Here is our top-level converter:</p><pre class="programlisting">
public class PersonDAOToPersonVOCopier extends PropertyNameMappingCopier {

	protected void copyImpl(Object destination, Object source, Locale locale)
		throws TransformationException {
		
		super.copyImpl(destination, source, locale);
		
		// this cast is safe because our superclass makes sure the source is of
		// the correct type and not null
		PersonDAO personDAO = (PersonDAO) source;
		// construct the name
		String name = personDAO.getFirstName() + " "
			+ personDAO.getMiddleName() + " " + personDAO.getLastName();
		
		// this cast is safe because our superclass makes sure the destination
		// is of the correct type and not null
		PersonVO personVO = (PersonVO) destination;
		// save the name
		personVO.setName(name);
		
	}
	
	protected Class[] getDestinationClassesImpl() throws Exception {
		return new Class[] { PersonVO.class };
	}
	
	protected Class[] getSourceClassesImpl() throws Exception {
		return new Class[] { PersonDAO.class };
	}
	
}
				</pre><p>Now that we have all our transformers written, we can go about performing our graph transformation.  We can do everything programmatically, or we can use a dependency injection framework.  Here is the code we'll need to do things programmatically:</p><pre class="programlisting">
// this is the overall transformer we'll use to do the graph copy
DelegatingTransformer graphTransformer = new DelegatingTransformer();

// AddressDAO[] to String
AddressDAOArrayToStringConverter addressConverter =
	new AddressDAOArrayToStringConverter();		
// PersonDAO[] to PersonVO[]
PropertyNameMappingCopier personCopier = new PersonDAOToPersonVOCopier();
Map personMapping = new HashMap();
personMapping.put("children", "children");
personMapping.put("addresses", "primaryAddress");
personMapping.put("vehicles", "vehicles");		
personCopier.setMapping(personMapping);
personCopier.setGraphTransformer(graphTransformer);

// the list of transformers that are involved in our overall graph
// transformation
List transformers = new ArrayList();
// always put your custom transformers first
transformers.add(personCopier);
transformers.add(addressConverter);

// then put in the default set of transformers as listed in the
// DelegatingTransformer.  this makes sure all the normal conversions
// you would expect from Morph are available (e.g. Integer 1 -&gt; Long 1)
transformers.add(new DefaultToBooleanConverter());
transformers.add(new NullConverter());
transformers.add(new IdentityConverter());
transformers.add(new DefaultToTextConverter());
transformers.add(new TextToNumberConverter());
transformers.add(new NumberConverter());
transformers.add(new TraverserConverter());
transformers.add(new TextConverter());
// will automatically take care of PersonDAO[] to String[]
transformers.add(new ContainerCopier());
// will automatically take care of VehicleDAO[] to VehicleVO[]
transformers.add(new PropertyNameMatchingCopier());

// convert our list of transformers into an array
Transformer[] transformerArray = (Transformer[]) transformers.toArray(
	new Transformer[transformers.size()]);
graphTransformer.setComponents(transformerArray);

// copy the information from personDAO to personVO
graphTransformer.copy(personVO, personDAO);
				</pre><p>Below is essentially the same code using Spring.  The code may not be much shorter, but I feel it's clearer</p><pre class="programlisting">
&lt;beans&gt;

	&lt;!-- VehicleDAO[] to VehicleVO[] --&gt;
	&lt;bean
		id="vehicleCopier"
		class="net.sf.morph.transform.copiers.PropertyNameMatchingCopier"/&gt;
	&lt;!-- PersonDAO[] to String[] --&gt;
	&lt;bean
		id="childrenCopier"
		class="net.sf.morph.transform.copiers.ContainerCopier"/&gt;
	&lt;!-- AddressDAO[] to String --&gt;
	&lt;bean
		id="addressCopier"
		class="net.sf.morph.examples.person.AddressDAOArrayToStringConverter"/&gt;
	&lt;!-- PersonDAO[] to PersonVO[] --&gt;
	&lt;bean
		id="personCopier"
		class="net.sf.morph.examples.person.PersonDAOToPersonVOCopier"&gt;
		&lt;property name="mapping"&gt;
			&lt;map&gt;
				&lt;entry key="children" value="children"/&gt;
				&lt;entry key="address" value="primaryAddress"/&gt;
				&lt;entry key="vehicles" value="vehicles"/&gt;
			&lt;/list&gt;
		&lt;/property&gt;
		&lt;property name="graphTransformer"&gt;
			&lt;ref bean="graphTransformer"/&gt;
		&lt;/property&gt;
	&lt;/bean&gt;

	&lt;!-- the overall transformer we'll use to do the graph copy --&gt;
	&lt;bean
		id="graphTransformer"
		class="net.sf.morph.transform.DelegatingCopier"&gt;
		&lt;property name="components"&gt;
			&lt;list&gt;
				&lt;ref bean="personCopier"/&gt;
				&lt;ref bean="vehicleCopier"/&gt;
				&lt;ref bean="childrenCopier"/&gt;
				&lt;ref bean="addressConverter"/&gt;
			&lt;/list&gt;
		&lt;/property&gt;
	&lt;/bean&gt;
	
&lt;/beans&gt;
				</pre></div></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="wrappers"></a>Chapter&nbsp;3.&nbsp;Wrappers</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="wrappers-introduction"></a>3.1.&nbsp;Introduction</h2></div></div><div></div></div><p>A wrapper allows data in an object to be manipulated and provides a consistent API for different types. For example, instead of overloading a method so that it can accept both a Collection and an Object array, a single method signature utilizing the Container interface may be specified.  <span class="emphasis"><em>This chapter has yet to be written</em></span></p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="contexts"></a>Chapter&nbsp;4.&nbsp;Contexts</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="contexts-introduction"></a>4.1.&nbsp;Introduction</h2></div></div><div></div></div><p>A context is an object that can be passed between tiers of an application without exposing the APIs that are particular to any given tier. For example, in a web application the information submitted by a user in an HttpRequest object could be exposed to a business object through the Context interface. This leaves objects in the business tier independent of the servlet API and thus testable outside a Servlet container.  <span class="emphasis"><em>This chapter has yet to be written</em></span></p></div></div></div></body></html>