<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;1.&nbsp;Introduction</title><link rel="stylesheet" href="../styles/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.60.1"><link rel="home" href="index.html" title="The Morph Framework"><link rel="up" href="index.html" title="The Morph Framework"><link rel="previous" href="preface.html" title="Preface"><link rel="next" href="transformers.html" title="Chapter&nbsp;2.&nbsp;Transformers"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter&nbsp;1.&nbsp;Introduction</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="preface.html">Prev</a>&nbsp;</td><th width="60%" align="center">&nbsp;</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="transformers.html">Next</a></td></tr></table><hr></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="introduction"></a>Chapter&nbsp;1.&nbsp;Introduction</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="introduction-started"></a>1.1.&nbsp;Getting Started</h2></div></div><div></div></div><p>The easiest way to use Morph is to use the <tt class="literal">Morph</tt> static class.  The main operations it supports are <tt class="literal"><a href="transformers.html#transformers-converters" title="2.2.&nbsp;The Converter Interface">convert</a></tt>, <tt class="literal"><a href="transformers.html#transformers-copiers" title="2.3.&nbsp;The Copier Interface">copy</a></tt>, <tt class="literal"><a href="">get</a></tt> and <tt class="literal"><a href="">set</a></tt>.  These methods allow you to: <tt class="literal">convert</tt> an object from one type to another, <tt class="literal">copy</tt> information from one object to another (already existing) object, retrieve (<tt class="literal">get</tt>) information from anywhere in an object graph and <tt class="literal">set</tt> information anywhere in an object graph, respectively.</p><p>The benefit of using the <tt class="literal">Morph</tt> static class directly is that it's simple, and you don't have to do any special setup.  No matter what project you're working on, all you have to do is drop the morph JAR into your project's library directory and reference the Morph class.  In addition, you are assured that no matter how the application you are working on is configured, Morph will work the way you're used to.</p><p>The drawback of using Morph in this way is that you cannot do any customization.  The <tt class="literal">Morph</tt> class is a static facade that makes it easy to get started using Morph.  To accomplish this goal, it hides all of the powerful customizations Morph provides.  Fortunately, once you outgrow the capabilities that come with Morph out of the box, your own custom Morph configuration will live peacefully side by side with the Morph static class.  Your existing code that utilizes the Morph static class will continue to work as it did before, and the parts of your application that require special configuration can have that special configuration limited to only those parts of the system that need the added complexity.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="introduction-convert"></a>1.1.1.&nbsp;Morph.convert</h3></div></div><div></div></div><p>Morph.convert allows you to convert an object from one type to another. Here are some examples:</p><pre class="programlisting">
Integer three = new Integer(3);
// code without Morph
String string = new Integer(three);
// or (without using Morph)
string = "" + three;
// code using Morph
String string = Morph.convertToString(three);

String three = "3";
// code without Morph
Integer integer = new Integer(three);
// code using Morph
Integer integer = Morph.convertToIntegerObject(three);

String three = "3";
// code without Morph
int i= new Integer(three).intValue();
// or (without using Morph)
int i = Integer.parseInt(3);
// code using Morph
int i = Morph.convertToInt(three);
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="introduction-copy"></a>1.1.2.&nbsp;Morph.copy</h3></div></div><div></div></div><p>Morph.copy allows information from one object to be copied to another object. The object to which information is copied may even be of a different type than the source object. A great example of when you need to do this type of thing is when you need the data in an HttpServletRequest to be available to lower tiers in your application but you don't want to tie your entire application to the servlet API. For example, let's say you are trying to get your data prepared for a method with a signature <tt class="literal">IServiceInterface.service(Map data):</tt></p><pre class="programlisting">
// without Morph
Map data = new HashMap();
for (Enumeration e=request.getParameterNames(); e.hasNext(); ) {
	String param = (String) e.next();
	data.put(param, request.getParameter(param));
}
// with Morph
Map data = new HashMap();
Morph.copy(data, request);
// actually with this particular example could also do
Map data = (Map) Morph.convert(Map.class, request);
</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="introduction-custom"></a>1.2.&nbsp;Customizing Morph</h2></div></div><div></div></div><p>A common convention in Java programming is to write objects as JavaBeans and expose their configuration parameters as JavaBean properties.  The Morph framework exposes all configuration options in this way.  This allows Morph to be configured programmatically using simple syntax.  An even more powerful way to configure Morph is to use a dependency injection framework such as Spring.  (Dependency injection frameworks are also sometimes called Inversion of Control containers, or IoC containers).  This will allow you to configure Morph using the same format you use to configure the rest of your application.</p><p>If you're completely lost at this point and wondering what the heck a dependency injection framework is, take a look <a href="http://www.picocontainer.org/Dependency+Injection" target="_top">here</a>.  Note that Morph uses Setter Injection rather than Constructor Injection.  I (Matt Sgarlata) personally think dependency injection containers are the most significant innovation in computer programming since object orientation.  If you don't know what dependency injection is, stop now and take a look at Spring, PicoContainer, or Hivemind!  My favorite is Spring.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="introduction-concepts"></a>1.3.&nbsp;Concepts</h2></div></div><div></div></div><p>There is a whole lot of code in the Morph framework, but it all boils down to a few basic types of things: Transformers, Reflectors, Wrappers, Languages and Contexts.  Each of these types of things is given its own package.  We'll use the remainder of this section to briefly cover these types.  For more information on a type, see the reference guide chapter about the type if one has been written.  If you need more information or there is no reference chapter, see the <a href="http://morph.sourceforge.net/apidocs/index.html" target="_top">JavaDoc</a> documentation.  Documentation can always be improved, but the documentation for each of the main interfaces is fairly complete.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="introduction-concepts-transformers"></a>1.3.1.&nbsp;Transformers</h3></div></div><div></div></div><p>Transformers transform data from one type to another.  Transformers were essentially the inspiration for the entire framework, and they are targeted pretty squarely at the original goal for the framework, which was "to be able to convert anything to anything".</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="introduction-concepts-reflectors"></a>1.3.2.&nbsp;Reflectors</h3></div></div><div></div></div><p>Reflectors were originally created to help implement Copiers, which are a type of Transformers.  They provide a stateless model for accessing data from two main types of data structures: bean-like structures and container-like structures.  It turns out reflectors are so useful, they can implement all sorts of neat functionality.  If you have some type of special data type that you need Morph to understand, you probably want to write a Reflector.  A good example of this is the <tt class="literal">DynaBeanReflector</tt></p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="introduction-concepts-wrappers"></a>1.3.3.&nbsp;Wrappers</h3></div></div><div></div></div><p>Wrappers are very similar to reflectors, and in fact their APIs are nearly identical.  The difference is that reflectors are stateless so that transformers can be implemented efficiently.  Wrappers are more useful when you want to allow a method to take any type of bean-like or container-like data, but you don't want to have to overload the method for every conceivable bean (e.g. Object, Map) or container (e.g. Array, List)</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="introduction-concepts-languages"></a>1.3.4.&nbsp;Languages</h3></div></div><div></div></div><p>Languages define a way to retrieve and modify arbitrary information in an object graph.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="introduction-concepts-contexts"></a>1.3.5.&nbsp;Contexts</h3></div></div><div></div></div><p>Contexts are similar to bean wrappers in that they provide stateful access to information stored in a bean-like object.  Unlike beans, contexts are backed by the full power of a language, so they can be used to modify and change any information in an object graph.  Also, the default context implementations provided with Morph implement the Map interface.  This allows you to easily pass Contexts between tiers of an application, even if different tiers of the application are dependent on different APIs (e.g. the Servlet API in the presentation tier and the JDBC API in the resource tier).</p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="preface.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="index.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="transformers.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Preface&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;2.&nbsp;Transformers</td></tr></table></div></body></html>